# MDTK Architecture

## `markdown-it` Background

MDTK relies on `markdown-it` to do the heavy lifting, so it's important to understand
the basics of how that package works to understand MDTK's internals.

### `markdown-it` rendering pipeline

`markdown-it` exposes a single function to parse and render markdown a markdown string to
HTML.

1. Parse the input to a token stream
2. Render the resulting tokens to HTML

The parser does not create an AST, the output is a a list of tokens.

It is possible to extend `markdown-it` using plugins. There are quite a few great plugins
out there, and MDTK also defines some of its own.

Plugins can be written to extend the parser (harder) or the renderer (easier).

This process is entirely synchronous.

### `markdown-it` plugins

Defining and using a plugin might look like this:

```javascript
// myplugin.js
module.exports = function myplugin(md, options) { // 1
    md.core.ruler.push("myplugin", function (state) { // 2
        state.tokens.forEach((token, idx) => { // 3
            if (token.tag === "section" && token.nesting === 1) { // 4
                state.tokens.splice(idx, 0, new state.Token("hr", "hr", 0));
            }
        });
    });
};

// main.js
md.use(require("./myplugin", { some: "option" })) // 5
```

1. the plugin constructor takes the `markdown-it` instance and some options
2. the constructor registers a handler function with the `markdown-it`instance by adding it to a `ruler`
3. the plugin uses information in the current parser state
4. and executes some logic to change the state (in this case, add an `<hr>` tag before every opening
    `<section>` tag)
5. after instantiating a `markdown-it` instance, the plugin is `use`d

`markdown-it` parses a document by iterating over several subparsers (called rules). The block ruler will split the document into blocks (paragraph, blockquote, table etc...), then the inline ruler will split each block into components (emphasis, anchor, image etc...). Each plugin processes the document completely before the parser invokes the next, so the ruler and position at which a plugin is hooked change its input and outputs.

### `markdown-it` tokens

Tokens are plain JS objects and contain just enough information for the renderer to do its job.

There are block level and inline tokens (note `block: true`):

```
{
    type: 'paragraph_open',
    tag: 'p',
    attrs: null,
    map: [ 2, 4 ],
    nesting: 1,
    level: 0,
    children: null,
    content: '',
    markup: '',
    info: '',
    meta: null,
    block: true,
    hidden: false
}
```

The following markdown:

```markdown
hello!
```

Generates the following token list:

```
type: paragraph_open, tag: p, children: null
type: inline, tag: '', children: [
    type: text, tag: '', children: null
]
type: paragraph_close, tag: p, children: null
```

## MDTK Rendering Pipeline

Let's take a look at the code for the CLI `render` command handler:

```javascript
const mdtk = new MDTK(argv); // 1
const tokens = await mdtk.tokenize(); // 2
const html = await mdtk.render(tokens); // 3
await mdtk.package(html); // 4
```

1. an mdtk instance is created using the options provided on the CLI
2. the input is tokenized and processed
3. the tokens are rendered to HTML
4. the HTML is packaged into a complete document and written to the output

> MDTK operations are _asynchronous_, contrary to `markdown-it`

This is because a number of operations in MDTK require async logic. A few examples:

* `@include` performs IO operations to retrieve fragment contents
* `@startvega`/`@startvegalite` render their specifications asynchronously

### MDTK Tokenizer

The code for tokenizing an MDTK markdown document looks like this:

```javascript
async tokenize() {
    let tokens = await tokenizeFragment.call(this); // 1
    tokens = await require("./postprocessor")(this, tokens); // 2
    return tokens;
}
```

1. `tokenizeFragment` is called (recursively) to parse the input and all included fragments
    1. Each fragment is parsed, using `markdown-it` and the extensions under `src/parser/`
        1. First, all `{{ variables }}` are interpolated using handlebars
        2. Other extensions such as `@startuml`, `@startvega` are tokenized
        3. `srcmap` adds a `src` property to each token indicating the path to its markdown fragment
    2. Then, all `@include` statements are processed, replacing the `@include` token with the tokens generated by the child fragment parser
2. `postprocessor` is invoked asynchronously to finalize the token stream
    1. `src/postprocessor/nest` splits the document into sections according to `hr` rules
    2. `src/postprocessor/transform` processes the `@atrules` that map to or modifiy HTML elements
    3. `src/postprocessor/resolve` adds referenced assets to the dependency manager and replacing local asset references with references relative to the output directory
    4. `src/postprocessor/prerender` executes any async tasks required by individual token types, e.g. render vega specifications SVG

### MDTK Renderer

This process is very simple, since the tokenizer has produced a token stream that is standard.

### MDTK Packager

The renderer has produced HTML content but not an HTML document, and the assets still live in their locations relative to the markdown fragments that reference them.

The packager's responsibility is to produce a complete output directory, including a complete document and asset directory.

This logic lives under `src/packager`.